<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Attack Seam Framework</title>
  <link rel="icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/public/img/head.png">
  <link rel="stylesheet" href="/public/css/amazeui.min.css">
  <link rel="stylesheet" href="/public/css/app.css">
  <link rel="stylesheet" href="/public/css/highlight-js/github.css">
</head>
<body>

<div class="am-container lp-container">
  <header class="am-topbar lp-topbar">
    <h1 class="am-topbar-brand">
      <a href="/">Tomato's Blog</a>
    </h1>
    <button class="am-topbar-btn am-topbar-toggle am-btn am-btn-sm am-btn-danger am-show-sm-only" data-am-collapse="{target: '#lp-topbar-collapse'}"><span class="am-sr-only">导航切换</span> <span class="am-icon-bars"></span></button>
    <div class="am-collapse am-topbar-collapse am-topbar-right" id="lp-topbar-collapse">
      <ul class="am-nav am-nav-pills am-topbar-nav">
        <li><a href="/">Archives</a></li>
        <!-- <li><a href="#">Categories</a></li> -->
        <li><a href="/friends.html">Friends</a></li>
        <!-- <li><a href="#">About Me</a></li> -->
        <li><a href="/feed.xml">Feed</a></li>
      </ul>
    </div>
  </header>
</div>


<div class="am-container lp-container">
  <div class="lp-post">
    <div class="lp-post-header">
      <h1 class="lp-post-title">Attack Seam Framework</h1>
      <div class="lp-post-meta">
        <i class="am-icon-calculator"></i><span class="lp-post-date">2018-03-28</span>
        <i class="am-icon-tags"></i><span class="lp-post-tags">vulnerability analysis</span>
      </div>
    </div>
    <div class="lp-post-content">
    <h2 id="杂谈">杂谈</h2>
<p>最近在看一些JavaWeb的漏洞，Java各种库的相互用来用去就导致了很多漏洞能在不同的场景进行利用。其中seam framework就是一个例子(本文所指的seam framework都是seam2系列)。它是属于Jboss阵营，虽然现在已经不再维护了但是还是有不少站点是基于这个框架开发的。程序员使用seam框架能更快速的开发JSF类型的站点，其中seam framework使用了Mojarra，Mojarra是Oracle对JSF标准的实现，Jboss在MoJarra的基础上开发了richfaces。因为seam 所使用的基础库的版本较低，所以该框架存在很多安全问题，下面具体就分析了CVE-2010-1871 CVE-2013-2165 CVE-2013-3827 这几个安全漏洞的成因和官方的修复方案。</p>
<h2 id="cve-2010-1871">CVE-2010-1871</h2>
<p>此漏洞是一个表达式注入类型的漏洞影响2.2.1之前的版本，seam Framework基于EL表达式自己写了一套jboss expression language。然后在此表达式中可以通过反射的方法去实例化<code class="highlighter-rouge">java.lang.Runtime</code>等类，然后进一步执行任意命令。其调用方式为<code class="highlighter-rouge">expressions.getClass().forName('java.lang.Runtime')</code>,若要执行命令的话通过反射的invoke方法就行，具体构造方式为<code class="highlighter-rouge">expressions.getClass().forName('java.lang.Runtime').getDeclaredMethods()[19].invoke(expressions.getClass().forName('java.lang.R
untime').getDeclaredMethods()[7].invoke(null), 'command')</code>
其中需要注意的是<code class="highlighter-rouge">getDeclaredMethods</code>得到的方法位置可能因为系统的不同有所不同，笔者测试环境为MacOS。其中<code class="highlighter-rouge">getDeclaredMethods()[19]</code> 与 <code class="highlighter-rouge">getDeclaredMethods()[7]</code>分别为<code class="highlighter-rouge">getRuntime</code>与<code class="highlighter-rouge">exec</code> 前面大概介绍了一下jboss expression language的利用方式，然后来具体看一下此次漏洞的成因。<code class="highlighter-rouge">org.jboss.seam.navigation.Pages</code> 此类是用来处理seam中各个页面之间的行为的，具体行为的配置在/WEB-INF/pages.xml。在 <code class="highlighter-rouge">preRender</code> 方法中调用了 <code class="highlighter-rouge">callAction</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   /**
    * Call the action requested by s:link or s:button.
    */
   private static boolean callAction(FacesContext facesContext)
   {
      //TODO: refactor with Pages.instance().callAction()!!
      
      boolean result = false;
      
      String outcome = facesContext.getExternalContext()
            .getRequestParameterMap().get("actionOutcome");
      String fromAction = outcome;
      
      if (outcome==null)
      {
         String actionId = facesContext.getExternalContext()
               .getRequestParameterMap().get("actionMethod");
         if (actionId!=null)
         {
            if ( !SafeActions.instance().isActionSafe(actionId) ) return result;
            String expression = SafeActions.toAction(actionId);
            result = true;
            MethodExpression actionExpression = Expressions.instance().createMethodExpression(expression);
            outcome = toString( actionExpression.invoke() );
            fromAction = expression;
            handleOutcome(facesContext, outcome, fromAction);
         }
      }
      else
      {
         handleOutcome(facesContext, outcome, fromAction);
      }
      
      return result;
   }
</code></pre></div></div>
<p>在http请求中获取<code class="highlighter-rouge">actionOutcome</code>后传入了<code class="highlighter-rouge">handleOutcome</code>在此调用了<code class="highlighter-rouge">facesContext.getApplication().getNavigationHandler().handleNavigation</code>其中handleNavigation是对JSF中<code class="highlighter-rouge">NavigationHandler</code>这个抽象类的实现，在<code class="highlighter-rouge">org.jboss.seam.jsf.seamNavigationHandler.handleNavigation</code>方法中进入了<code class="highlighter-rouge">FacesManager.instance().interpolateAndRedirect()</code>最后在此方法中的<code class="highlighter-rouge">Interpolator.instance().interpolate</code>进行了表达式的解析。测试如下图所示
<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-27-15221387286515.jpg" alt="" />
该漏洞后续修复方式为在actionOutcome中检查是否包含<code class="highlighter-rouge">#{</code>等字符来防止表达式注入。虽然这样是直接杜绝了在actionOutcome参数中进行表达式注入，但是我们注意下面的代码</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(outcome == null) {
                String actionId = (String)facesContext.getExternalContext().getRequestParameterMap().get("actionMethod");
                if (actionId != null) {
                    if (!SafeActions.instance().isActionSafe(actionId)) {
                        return result;
                    }

                    String expression = SafeActions.toAction(actionId);
                    result = true;
                    MethodExpression actionExpression = Expressions.instance().createMethodExpression(expression);
                    outcome = toString(actionExpression.invoke(new Object[0]));
                    handleOutcome(facesContext, outcome, expression);
                }
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">actionId</code>在经过一系列检查之后还是生成了<code class="highlighter-rouge">expression</code>进入了<code class="highlighter-rouge">handleOutcome</code>方法中，来看看经过了一些什么检查。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    public boolean isActionSafe(String id) {
        if (this.safeActions.contains(id)) {
            return true;
        } else {
            int loc = id.indexOf(58);
            if (loc &lt; 0) {
                throw new IllegalArgumentException("Invalid action method " + id);
            } else {
                String viewId = id.substring(0, loc);
                String action = "\"#{" + id.substring(loc + 1) + "}\"";
                InputStream is = FacesContext.getCurrentInstance().getExternalContext().getResourceAsStream(viewId);
                if (is == null) {
                    throw new IllegalStateException("Unable to read view /" + viewId + " to execute action " + action);
                } else {
                    BufferedReader reader = new BufferedReader(new InputStreamReader(is));

                    try {
                        while(true) {
                            boolean var7;
                            if (reader.ready()) {
                                if (!reader.readLine().contains(action)) {
                                    continue;
                                }

                                this.addSafeAction(id);
                                var7 = true;
                                return var7;
                            }

                            var7 = false;
                            return var7;
                        }
                    } catch (IOException var17) {
                        throw new RuntimeException("Error parsing view /" + viewId + " to execute action " + action, var17);
                    } finally {
                        try {
                            reader.close();
                        } catch (IOException var16) {
                            throw new RuntimeException(var16);
                        }
                    }
                }
            }
        }
    }

</code></pre></div></div>
<p>通过这个方法我们可以知道，如果利用<code class="highlighter-rouge">actionId</code>来进行表达式注入，那么我们需要有一个可以控制内容的资源文件，在这个资源文件中包含我们需要执行的EL表达式。例如在web目录存在一个/img/test.jpg的文件，里面包含你要执行的EL表达式，构造如下请求就能执行<code class="highlighter-rouge">/test.seam?actionMethod:test/test.jpg:EL表达式</code>。在hitcon 2016 的Angry seam题中就有一处利用。在template.xhtml中有如下代码</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
var NAME="#{util.escape(sessionScope['user'].getUsername())}";
var SID="#{util.escape(cookie['JSESSIONID'].value)}";
var DESC="#{util.escape(sessionScope['user'].getDescription())}";
&lt;/script&gt;
</code></pre></div></div>
<p>其中DESC我们可以自己设置，首先将我们的DESC设置为<code class="highlighter-rouge">?x=#{expressions.instance().createValueExpression(request.getHeader('cmd')).getValue()}</code>其含义就是获取请求头中的cmd。然后在请求<code class="highlighter-rouge">template.seam?actionMethod=template.xhtml:util.escape(sessionScope['user'].getDescription())</code>通过前面的代码分析我们知道其实就是去执行<code class="highlighter-rouge">util.escape(sessionScope['user'].getDescription())</code>这个表达式，将此表达式执行的结果赋值给了<code class="highlighter-rouge">outname</code>，然后将<code class="highlighter-rouge">outname</code>传递给<code class="highlighter-rouge">handleOutcome</code>方法，又执行了一次表达式。所以这是一个EL表达式二次执行的问题。此处执行的表达式就是DESC设置的表达式，因为在DESC中通过表达式再次实例化了一个表达式执行的实例，所以cmd中的表达式得到执行。
<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-28-15222283869796.jpg" alt="" /></p>

<h2 id="cve-2013-2165">CVE-2013-2165</h2>
<p>seam框架在2.2.1版本时使用的richfaces的版本为3.3.3.Final，此版本存在一处Java反序列化漏洞。因此这个漏洞也直接影响seam框架，通过这个漏洞我们可以直接实现RCE。下面简单分析一下此漏洞，该漏洞核心源码是 org.ajax4jsf.resource.ResourceBuilderImpl</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.....

private static final Pattern DATA_SEPARATOR_PATTERN = Pattern.compile("/DAT(A|B)/");

......

public Object getResourceDataForKey(String key) {
        Object data = null;
        String dataString = null;
        Matcher matcher = DATA_SEPARATOR_PATTERN.matcher(key);
        if (matcher.find()) {
            if (log.isDebugEnabled()) {
                log.debug(Messages.getMessage("RESTORE_DATA_FROM_RESOURCE_URI_INFO", key, dataString));
            }

            int dataStart = matcher.end();
            dataString = key.substring(dataStart);
            byte[] objectArray = null;

            try {
                byte[] dataArray = dataString.getBytes("ISO-8859-1");
                objectArray = this.decrypt(dataArray);
            } catch (UnsupportedEncodingException var12) {
                ;
            }

            if ("B".equals(matcher.group(1))) {
                data = objectArray;
            } else {
                try {
                    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(objectArray));
                    data = in.readObject();
                } catch (StreamCorruptedException var9) {
                    log.error(Messages.getMessage("STREAM_CORRUPTED_ERROR"), var9);
                } catch (IOException var10) {
                    log.error(Messages.getMessage("DESERIALIZE_DATA_INPUT_ERROR"), var10);
                } catch (ClassNotFoundException var11) {
                    log.error(Messages.getMessage("DATA_CLASS_NOT_FOUND_ERROR"), var11);
                }
            }
        }

        return data;
    }
</code></pre></div></div>
<p>这段代码很简单，就是将传递过来的key进行解密之后的数据传入了readObject方法从而导致RCE。那么问题是这个key是如何输入的呢？这就是涉及到richfaces这个库了。这个库会去处理在URL中以/a4j/开头的路径，当你请求http://test.com/a4j/xxx 之后，中间件会将/a4j/xxxx 传递给richfaces这个库去处理后面的数据。具体代码为
<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-27-15221228205237.jpg" alt="" />
继续构造</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/a4j/g/3_3_3.Finalorg/richfaces/renderkit/html/scripts/skinning.js/DATA/xxxx 
</code></pre></div></div>
<p>这种格式的URL之后richfaces会将/a4j/a/3_3_3.Final先去除，这是个根据版本信息所产生的标识，然后找到org/richfaces/renderkit/html/scripts/skinning.js/此资源之后将后面的参数传入了getResourceDataForKey当中，然后/DATA/之后的数据经过一个decrypt方法之后就进入了readObject方法。其具体调用链如下:
<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-27-15220710395443.jpg" alt="" />
明白漏洞流程之后就可以直接通过ysoserial来进行RCE了。
<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-27-15220712257975.jpg" alt="" />
richfaces开发团队在richfaces3.3.4.Final对此漏洞进行了修复，修复方案是在反序列化时检测了类是否在白名单内。白名单文件在org.ajax4jsf.resource.resource-serialization.properties 大概看了一下似乎默认的这些类都无法利用起来。<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-27-15221303506179.jpg" alt="" /></p>

<h2 id="cve-2013-3827">CVE-2013-3827</h2>
<p>这个path traversal是在Mojarra2.0-2.1.18之间都存在，由于seam Framework 2.3.1 Final中Mojarra版本为2.1.7，所以存在此漏洞。但是seam Framework 2.2.1 Final使用的是Mojarra1.2.12所以不存在此漏洞。在分析漏洞成因之前需要了解一下seam框架的处理流程，通常在web.xml中能看到如下配置</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	&lt;filter&gt;
		&lt;filter-name&gt;seam Filter&lt;/filter-name&gt;
		&lt;filter-class&gt;org.jboss.seam.servlet.seamFilter&lt;/filter-class&gt;
	&lt;/filter&gt;
	&lt;filter-mapping&gt;
		&lt;filter-name&gt;seam Filter&lt;/filter-name&gt;
		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
	&lt;/filter-mapping&gt;
	&lt;servlet&gt;
		&lt;servlet-name&gt;seam Resource Servlet&lt;/servlet-name&gt;
		&lt;servlet-class&gt;org.jboss.seam.servlet.seamResourceServlet&lt;/servlet-class&gt;
	&lt;/servlet&gt;
	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;seam Resource Servlet&lt;/servlet-name&gt;
		&lt;url-pattern&gt;/resource/*&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;
	&lt;servlet&gt;
		&lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
		&lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
	&lt;/servlet&gt;
	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
		&lt;url-pattern&gt;*.seam&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;
</code></pre></div></div>
<p>当一个请求为 http://target.com/javax.faces.resource/xxxx 时，首先要经过 seam Filter的判断，只有在seam框架内部的filter处理完成之后才会将对应的请求发送给Mojarra处理。下面这张调用栈的图就很好的展示了整个流程
<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-28-15222171907906.jpg" alt="" />
漏洞的触发点是在Mojarra对资源文件请求的处理过程，其中<code class="highlighter-rouge">com.sun.faces.application.resource.WebappResourceHelper.findResource</code>是处理资源路径的关键方法，在此方法中完成了路径的拼接。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if (library != null) {
            basePath = library.getPath() + '/' + resourceName;
        } else {
            if (localePrefix == null) {
                basePath = getBaseResourcePath() + '/' + resourceName;
            } else {
                basePath = getBaseResourcePath()
                           + '/'
                           + localePrefix
                           + '/'
                           + resourceName;
            }
        }
</code></pre></div></div>
<p>我们传递的resourceName通过下面的代码所获取到</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>String resourceId = normalizeResourceRequest(context);
        // handleResourceRequest called for a non-resource request,
        // bail out.
        if (resourceId == null) {
            return;
        }
        
        ExternalContext extContext = context.getExternalContext();

        if (isExcluded(resourceId)) {
            extContext.setResponseStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        assert (null != resourceId);
        assert (resourceId.startsWith(RESOURCE_IDENTIFIER));

        Resource resource = null;
        String resourceName = null;
        String libraryName = null;
        if (ResourceHandler.RESOURCE_IDENTIFIER.length() &lt; resourceId.length()) {
            resourceName = resourceId.substring(RESOURCE_IDENTIFIER.length() + 1);
            assert(resourceName != null);
            libraryName = context.getExternalContext().getRequestParameterMap()
                  .get("ln");
            resource = context.getApplication().getResourceHandler().createResource(resourceName, libraryName);
        }
</code></pre></div></div>
<p>这段代码中先是得到resourceId的值为<code class="highlighter-rouge">/javax.faces.resource/xxxx</code>，再判断了资源文件类型，默认情况下以下几种类型的文件是无法访问
<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-28-15222182213175.jpg" alt="" />
所以该漏洞默认情况下是无法读取以上几种文件的内容。<code class="highlighter-rouge">resourceName</code>通过<code class="highlighter-rouge">resourceName = resourceId.substring(RESOURCE_IDENTIFIER.length() + 1)</code>赋值，若我们将请求设置为 http://target.com/javax.faces.resource…/WEB-INF/web.xml.seam 那么<code class="highlighter-rouge">resourceName</code>就为<code class="highlighter-rouge">../WEB-INF/web.xml</code>了。再通过后面<code class="highlighter-rouge">findResource</code>方法的拼接最后<code class="highlighter-rouge">basepath</code>的值就为<code class="highlighter-rouge">/resources/../WEB-INF/web.xml</code>因而成功读取到web.xml里面的数据了。
<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-28-15222200461324.jpg" alt="" />
除此之外还有另外一种利用方式，其实过程也大同小异。就是利用<code class="highlighter-rouge">libraryName</code> 来进行跳目录，其赋值方式为<code class="highlighter-rouge">libraryName=context.getExternalContext().getRequestParameterMap().get("ln");</code>将请求的URL改为 <code class="highlighter-rouge">http://target.com/javax.faces.resource/javax.faces.resource./WEB-INF/web.xml.seam?ln=..</code> 然后basepath通过<code class="highlighter-rouge">basePath = library.getPath() + '/' + resourceName;</code>赋值为<code class="highlighter-rouge">/resources/../WEB-INF/web.xml</code>也一样读取到了web.xml的内容了。
<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-28-15222206254018.jpg" alt="" />
其实在第二种利用方式中，程序本身检查通过<code class="highlighter-rouge">libraryNameContainsForbiddenSequence</code>检测了<code class="highlighter-rouge">libraryName</code>的值，但是黑名单字符中不包含<code class="highlighter-rouge">..</code> 官方在后面的修复方案就是将<code class="highlighter-rouge">..</code>加入黑名单并且同时检查了<code class="highlighter-rouge">resourceName</code>和<code class="highlighter-rouge">libraryName</code>是否合法。
<img src="http://ogmho3r7t.bkt.clouddn.com/2018-03-28-15222210619941.jpg" alt="" /></p>

<h2 id="参考">参考</h2>
<p><a href="http://blog.o0o.nu/2010/07/cve-2010-1871-jboss-seam-framework.html">cve-2010-1871-jboss-seam-framework</a></p>

<p><a href="http://www.melodia.pw/?p=743">HITCON 2016 WEB WRITEUP</a></p>

<p><a href="https://github.com/orangetw/My-CTF-Web-Challenges/">My-CTF-Web-Challenges</a></p>

<p><a href="http://vnprogramming.com/index.php/2016/10/10/web500-hitconctf-2016-and-exploit-cve-2013-2165/">web500-hitconctf-2016-and-exploit-cve-2013-2165</a></p>

<p><a href="https://www.synopsys.com/blogs/software-security/path-traversal-defects-oracles-jsf2-implementation/">path-traversal-defects-oracles-jsf2-implementation</a></p>


    </div>
    
    <div id="disqus_thread"></div>
<script type="text/javascript">
var disqus_shortname = "tomatos-blog";

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>
</div>

<div class="am-container lp-container">
  <footer class="am-footer lp-footer">
    <p>Copyright © 2014-2017 All Rights Reserved</p>
    <p>Theme By <a href="https://github.com/RickGray/light-post">LightPost</a></p>
  </afooter>
</div>


<div data-am-widget="gotop" class="am-gotop am-gotop-fixed">
  <a href="#top" title="回到顶部">
    <span class="am-gotop-title">GoTop</span>
    <i class="am-gotop-icon am-icon-chevron-up"></i>
  </a>
</div>

<script src="/public/js/jquery.min.js"></script>
<script src="/public/js/amazeui.min.js"></script>
<script>
$(document).ready(function(){
  $.AMUI.progress.start();
});
$(window).load(function(){
  $.AMUI.progress.done();
});
</script>
<script src="/public/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!-- 网站统计代码 -->
<div hidden>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256394309'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256394309%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</div>
<div hidden>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b8f48a0cd4b04ec22678a4cd23fcb9dd";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</div>
</body>
</html>
